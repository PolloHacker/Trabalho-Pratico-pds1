[
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            a2t --> a2t1([Fim])\n        a2 -- false --> a2f[define os pokemons atacante e defensor]\n            a2f -- mais_forte, mais_fraco --> a2f1[determina a força do ataque com base nos tipos]\n            a2f1 --> a2f2[calcula o hp a ser retirado do defensor]\n            a2f2 --> a2f3{o defensor foi derrotado?}\n            a2f3 -- true --> a2f3t[avança o contador de pokemon\n             atual do jogador defensor]\n                a2f3t --> a2f3t1[/Imprime qual pokemon venceu/]\n                a2f3t1 --> a2f4([retorna])\n            a2f3 -- false --> a2f4\n    end\n\n    subgraph checa_sobreviventes\n    direction TB\n        cs1[recebe o array de jogadores \n        e o índice do vencedor] --> cs2[inicializa um contador como o número\n         do pokemon atual do jogador vencedor]\n        cs2 --> cs3{o contador é menor do que a\n         quantidade de pokemons do vencedor?}\n        cs3 -- true --> cs3t[/Imprime o nome do pokemon/]\n            cs3t --> cs3\n        cs3 -- false --> cs4([retorna])\n    end\n\n    subgraph checa_derrotados\n    direction TB\n        cd1[recebe o array de jogadores] --> cd2[inicializa um contador como o número\n         do pokemon atual do jogador 1]\n        cd2 --> cd3{o contador é menor do que o \n        número do pokemon atual do jogador 1?}\n        cd3 -- true --> cd3t[/Imprime o nome do pokemon/]\n            cd3t --> cd3\n        cd3 -- false --> cd3f[inicializa o contador como o número\n         do pokemon atual do jogador 2]\n            cd3f --> cd3f1{o contador é menor do que o \n        número do pokemon atual do jogador 2?}\n            cd3f1 -- true --> cd3f1t[/Imprime o nome do pokemon/]\n                cd3f1t --> cd3f1\n            cd3f1 -- false --> cd3f1f([retorna])\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 64.50383833656315,
                "y": -82.98809986832758
            },
            "zoom": 2.3901922702789307,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718485722973,
        "type": "auto",
        "id": "4a937d62-5453-48ff-a8c7-ea3d70b9a5bd",
        "name": "nutritious-tiger"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            a2t --> a2t1([Fim])\n        a2 -- false --> a2f[define os pokemons atacante e defensor]\n            a2f -- mais_forte, mais_fraco --> a2f1[determina a força do ataque com base nos tipos]\n            a2f1 --> a2f2[calcula o hp a ser retirado do defensor]\n            a2f2 --> a2f3{o defensor foi derrotado?}\n            a2f3 -- true --> a2f3t[avança o contador de pokemon\n             atual do jogador defensor]\n                a2f3t --> a2f3t1[/Imprime qual pokemon venceu/]\n                a2f3t1 --> a2f4([retorna])\n            a2f3 -- false --> a2f4\n    end\n\n    subgraph checa_sobreviventes\n    direction TB\n        cs1[recebe o array de jogadores \n        e o índice do vencedor] --> cs2[inicializa um contador como o número\n         do pokemon atual do jogador vencedor]\n        cs2 --> cs3{o contador é menor do que a\n         quantidade de pokemons do vencedor?}\n        cs3 -- true --> cs3t[/Imprime o nome do pokemon/]\n            cs3t --> cs3\n        cs3 -- false --> cs4([retorna])\n    end\n\n    subgraph checa_derrotados\n    direction TB\n        cd1[recebe o array de jogadores] --> cd2[inicializa um contador como o número\n         do pokemon atual do jogador 1]\n        cd2 --> cd3{o contador é menor do que o \n        número do pokemon atual do jogador 1?}\n        cd3 -- true --> cd3t[/Imprime o nome do pokemon/]\n            cd3t --> cd3\n        cd3 -- false --> cd3f[inicializa o contador como o número\n         do pokemon atual do jogador 2]\n            cd3f --> cd3f1{o contador é menor do que o \n        número do pokemon atual do jogador 2?}\n            cd3f1 -- true --> cd3f1t[/Imprime o nome do pokemon/]\n                cd3f1t --> cd3f1\n            cd3f1 -- false --> cd3f1f([retorna])\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 64.50383833656315,
                "y": -82.98809986832758
            },
            "zoom": 2.3901922702789307,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718485701197,
        "type": "manual",
        "id": "91629232-f0c0-4698-9b34-ec8f33ae4d9e",
        "name": "freezing-hydrogen"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            a2t --> a2t1([Fim])\n        a2 -- false --> a2f[define os pokemons atacante e defensor]\n            a2f -- mais_forte, mais_fraco --> a2f1[determina a força do ataque com base nos tipos]\n            a2f1 --> a2f2[calcula o hp a ser retirado do defensor]\n            a2f2 --> a2f3{o defensor foi derrotado?}\n            a2f3 -- true --> a2f3t[avança o contador de pokemon\n             atual do jogador defensor]\n                a2f3t --> a2f3t1[/Imprime qual pokemon venceu/]\n                a2f3t1 --> a2f4([retorna])\n            a2f3 -- false --> a2f4\n    end\n\n    subgraph checa_sobreviventes\n    direction TB\n        cs1[recebe o array de jogadores \n        e o índice do vencedor] --> cs2[inicializa um contador como o número\n         do pokemon atual do jogador vencedor]\n        cs2 --> cs3{o contador é menor do que a\n         quantidade de pokemons do vencedor?}\n        cs3 -- true --> cs3t[/Imprime o nome do pokemon/]\n            cs3t --> cs3\n        cs3 -- false --> cs4([retorna])\n    end\n\n    subgraph checa_derrotados\n    direction TB\n        cd1[recebe o array de jogadores] --> cd2[inicializa um contador como o número\n         do pokemon atual do jogador 1]\n        cd2 --> cd3{o contador é menor do que o \n        número do pokemon atual do jogador 1?}\n        cd3 -- true --> cd3t[/Imprime o nome do pokemon/]\n            cd3t --> cd3\n        cd3 -- false --> cd3f[inicializa o contador como o número\n         do pokemon atual do jogador 2]\n            cd3f --> cd3f1{o contador é menor do que o \n        número do pokemon atual do jogador 2?}\n            cd3f1 -- true --> cd3f1t[/Imprime o nome do pokemon/]\n                cd3f1t --> cd3f1\n            cd3f1 -- false --> cd3f1f([retorna])\n        \n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 64.50383833656315,
                "y": -82.98809986832758
            },
            "zoom": 2.3901922272962124,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718485691653,
        "type": "manual",
        "id": "583ccbdf-8c06-4d00-830e-136e57298e35",
        "name": "obedient-terabyte"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            a2t --> a2t1([Fim])\n        a2 -- false --> a2f[define os pokemons atacante e defensor]\n            a2f -- mais_forte, mais_fraco --> a2f1[determina a força do ataque com base nos tipos]\n            a2f1 --> a2f2[calcula o hp a ser retirado do defensor]\n            a2f2 --> a2f3{o defensor foi derrotado?}\n            a2f3 -- true --> a2f3t[avança o contador de pokemon\n             atual do jogador defensor]\n                a2f3t --> a2f3t1[/Imprime qual pokemon venceu/]\n                a2f3t1 --> a2f4([retorna])\n            a2f3 -- false --> a2f4\n    end\n\n    subgraph checa_sobreviventes\n    direction TB\n        cs1[recebe o array de jogadores \n        e o índice do vencedor] --> cs2[inicializa um contador como o número\n         do pokemon atual do jogador vencedor]\n        cs2 --> cs3{o contador é menor do que a\n         quantidade de pokemons do vencedor?}\n        cs3 -- true --> cs3t[/Imprime o nome do pokemon/]\n            cs3t --> cs3\n        cs3 -- false --> cs4([retorna])\n    end\n\n    subgraph checa_derrotados\n    direction TB\n        cd1[recebe o array de jogadores] --> cd2[inicializa um contador como o número\n         do pokemon atual do jogador 1]\n        cd2 --> cd3{o contador é menor do que o \n        número do pokemon atual do jogador 1?}\n        cd3 -- true --> cd3t[/Imprime o nome do pokemon/]\n            cd3t --> cd3\n        cd3 -- false --> cd3f[inicializa o contador como o número\n         do pokemon atual do jogador 2]\n            cd3f --> cd3f1{o contador é menor do que o \n        número do pokemon atual do jogador 2?}\n            cd3f1 -- true --> cd3f1t[/Imprime o nome do pokemon/]\n                cd3f1t --> cd3f1\n            cd3f1\n        \n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 56.046238843951,
                "y": -406.0392117051541
            },
            "zoom": 4.090429306030273,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718485662364,
        "type": "auto",
        "id": "4aa2ad22-94c8-4f7d-9b45-a82889f2016e",
        "name": "helpful-accident"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            a2t --> a2t1([Fim])\n        a2 -- false --> a2f[define os pokemons atacante e defensor]\n            a2f -- mais_forte, mais_fraco --> a2f1[determina a força do ataque com base nos tipos]\n            a2f1 --> a2f2[calcula o hp a ser retirado do defensor]\n            a2f2 --> a2f3{o defensor foi derrotado?}\n            a2f3 -- true --> a2f3t[avança o contador de pokemon\n             atual do jogador defensor]\n                a2f3t --> a2f3t1[/Imprime qual pokemon venceu/]\n                a2f3t1 --> a2f4([retorna])\n            a2f3 -- false --> a2f4\n    end\n\n    subgraph checa_sobreviventes\n    direction TB\n        cs1[recebe o array de jogadores \n        e o índice do vencedor] --> cs2[inicializa um contador como o número\n         do pokemon atual do jogador vencedor]\n        cs2 --> cs3{o contador é menor do que a\n         quantidade de pokemons do vencedor?}\n        cs3 -- true --> cs3t[/Imprime o nome do pokemon/]\n            cs3t --> cs3\n        cs3 -- false --> cs4([retorna])\n    end\n\n    subgraph checa_derrotados\n    direction TB\n        cd1[recebe o array de jogadores] --> cd2[inicializa um contador como o número\n         do pokemon atual do jogador 1]\n        cd2 --> cd3{o contador é menor do que o \n        número do pokemon atual do jogador?}\n        cd3 -- true --> cd3t[/Imprime o nome do pokemon/]\n            cd3t --> cd3\n        cd3 -- false --> cd3f[inicializa o contador como o número\n         do pokemon atual do jogador 2]\n            cd3f --> cd3f1{}\n        \n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 56.046238843951,
                "y": -406.0392117051541
            },
            "zoom": 4.090429306030273,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718485602365,
        "type": "auto",
        "id": "f964cc30-d1e3-4aef-b556-14bf971605f1",
        "name": "quick-piano"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            a2t --> a2t1([Fim])\n        a2 -- false --> a2f[define os pokemons atacante e defensor]\n            a2f -- mais_forte, mais_fraco --> a2f1[determina a força do ataque com base nos tipos]\n            a2f1 --> a2f2[calcula o hp a ser retirado do defensor]\n            a2f2 --> a2f3{o defensor foi derrotado?}\n            a2f3 -- true --> a2f3t[avança o contador de pokemon\n             atual do jogador defensor]\n                a2f3t --> a2f3t1[/Imprime qual pokemon venceu/]\n                a2f3t1 --> a2f4([retorna])\n            a2f3 -- false --> a2f4\n    end\n\n    subgraph checa_sobreviventes\n    direction TB\n        cs1[recebe o array de jogadores \n        e o índice do vencedor] --> cs2[inicializa um contador como o número\n         do pokemon atual do jogador vencedor]\n        cs2 --> cs3{o contador é menor do que a\n         quantidade de pokemons do vencedor?}\n        cs3 -- true --> cs3t[/Imprime o nome do pokemon/]\n            cs3t --> cs3\n        cs3 -- false --> cs4([retorna])\n    end\n\n    subgraph checa_derrotados\n    direction TB\n        cd1[recebe o array de jogadores] --> cd2[inicializa um contador como o número\n         do pokemon atual do jogador 1]\n        cd2 --> cd3{o contador é menor do que o \n        número do pokemon atual do jogador?}\n        cd3 -- true --> cd3t[/Imprime o nome do pokemon/]\n            cd3t --> cd3\n        cd3 -- false --> cd4[inicializa o contador como o número\n         do pokemon atual do jogador 2]\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 56.046238843951,
                "y": -406.0392117051541
            },
            "zoom": 4.090429306030273,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718485542371,
        "type": "auto",
        "id": "602c966b-6f39-4256-ad83-8dcc9eaf9a80",
        "name": "scarce-animal"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            a2t --> a2t1([Fim])\n        a2 -- false --> a2f[define os pokemons atacante e defensor]\n            a2f -- mais_forte, mais_fraco --> a2f1[determina a força do ataque com base nos tipos]\n            a2f1 --> a2f2[calcula o hp a ser retirado do defensor]\n            a2f2 --> a2f3{o defensor foi derrotado?}\n            a2f3 -- true --> a2f3t[avança o contador de pokemon\n             atual do jogador defensor]\n                a2f3t --> a2f3t1[/Imprime qual pokemon venceu/]\n                a2f3t1 --> a2f4([retorna])\n            a2f3 -- false --> a2f4\n    end\n\n    subgraph checa_sobreviventes\n    direction TB\n        cs1[recebe o array de jogadores \n        e o índice do vencedor] --> cs2[inicializa um contador como o número\n         do pokemon atual do jogador vencedor]\n        cs2 --> cs3{o contador é menor do que a\n         quantidade de pokemons do vencedor?}\n        cs3 -- true --> cs3t[/Imprime o nome do pokemon/]\n            cs3t --> cs3\n        cs3 -- false --> cs4([retorna])\n    end\n\n    subgraph checa_derrotados\n    direction TB\n        cd1[recebe o array de jogadores] --> cd2[inicializa um contador como o número\n         do pokemon atual do jogador 1]\n        cd2 --> cd3{o contador é menor do que o \n        número do pokemon atual do jogador?}\n        cd3 -- true --> cd3t[/Imprime o nome do pokemon/]\n            cd3t --> cd3\n        cd3 -- false --> cd3f[]\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 119.08617783774844,
                "y": -72.68711662770386
            },
            "zoom": 2.580872058868408,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718485482371,
        "type": "auto",
        "id": "a2d9bb5b-add0-4755-a1e6-c231df106eda",
        "name": "dry-oil"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            a2t --> a2t1([Fim])\n        a2 -- false --> a2f[define os pokemons atacante e defensor]\n            a2f -- mais_forte, mais_fraco --> a2f1[determina a força do ataque com base nos tipos]\n            a2f1 --> a2f2[calcula o hp a ser retirado do defensor]\n            a2f2 --> a2f3{o defensor foi derrotado?}\n            a2f3 -- true --> a2f3t[avança o contador de pokemon\n             atual do jogador defensor]\n                a2f3t --> a2f3t1[/Imprime qual pokemon venceu/]\n                a2f3t1 --> a2f4([retorna])\n            a2f3 -- false --> a2f4\n    end\n\n    subgraph checa_sobreviventes\n    direction TB\n        cs1[recebe o array de jogadores \n        e o índice do vencedor] --> cs2[inicializa um contador como o número\n         do pokemon atual do jogador vencedor]\n        cs2 --> cs3{o contador é menor do que a\n         quantidade de pokemons do vencedor?}\n        cs3 -- true --> cs3t[/Imprime o nome do pokemon/]\n            cs3t --> cs3\n        cs3 -- false --> cs4([retorna])\n    end\n\n    subgraph checa_derrotados\n    direction TB\n        cd1[recebe o array de jogadores] --> cd2[inicializa um contador como o número\n         do pokemon atual do jogador 1]\n        cd2 --> cd3{o contador é menor do que o c}\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 119.08617783774844,
                "y": -72.68711662770386
            },
            "zoom": 2.580872058868408,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718485422374,
        "type": "auto",
        "id": "af865fd2-6d89-4cb2-aa22-8ae7012728c8",
        "name": "numerous-pilot"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            a2t --> a2t1([Fim])\n        a2 -- false --> a2f[define os pokemons atacante e defensor]\n            a2f -- mais_forte, mais_fraco --> a2f1[determina a força do ataque com base nos tipos]\n            a2f1 --> a2f2[calcula o hp a ser retirado do defensor]\n            a2f2 --> a2f3{o defensor foi derrotado?}\n            a2f3 -- true --> a2f3t[avança o contador de pokemon\n             atual do jogador defensor]\n                a2f3t --> a2f3t1[/Imprime qual pokemon venceu/]\n                a2f3t1 --> a2f4([retorna])\n            a2f3 -- false --> a2f4\n    end\n\n    subgraph checa_sobreviventes\n    direction TB\n        cs1[recebe o array de jogadores \n        e o índice do vencedor] --> cs2[inicializa um contador como o número\n         do pokemon atual do jogador vencedor]\n        cs2 --> cs3{o contador é menor do que a\n         quantidade de pokemons do vencedor?}\n        cs3 -- true --> cs3t[/Imprime o nome do pokemon/]\n            cs3t --> cs3\n        cs3 -- false --> cs4([retorna])\n    end\n\n    subgraph checa_derrotados\n    direction TB\n        cd1[recebe o array de jogadores] --> cd2[inicializa um contador como o número\n         do pokemon atual do jogador vencedor]\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 119.08617783774844,
                "y": -72.68711662770386
            },
            "zoom": 2.580872058868408,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718485362380,
        "type": "auto",
        "id": "9ccc26c4-e548-4b46-8934-21185b938c95",
        "name": "astonishing-teenager"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            a2t --> a2t1([Fim])\n        a2 -- false --> a2f[define os pokemons atacante e defensor]\n            a2f -- mais_forte, mais_fraco --> a2f1[determina a força do ataque com base nos tipos]\n            a2f1 --> a2f2[calcula o hp a ser retirado do defensor]\n            a2f2 --> a2f3{o defensor foi derrotado?}\n            a2f3 -- true --> a2f3t[avança o contador de pokemon\n             atual do jogador defensor]\n                a2f3t --> a2f3t1[/Imprime qual pokemon venceu/]\n                a2f3t1 --> a2f4([retorna])\n            a2f3 -- false --> a2f4\n    end\n\n    subgraph checa_sobreviventes\n    direction TB\n        cs1[recebe o array de jogadores \n        e o índice do vencedor] --> cs2[inicializa um contador como o número\n         do pokemon atual do jogador vencedor]\n        cs2 --> cs3{o contador é menor do que a\n         quantidade de pokemons do vencedor?}\n        cs3 -- true --> cs3t[/Imprime o nome do pokemon/]\n            cs3t --> cs3t\n        cs3 -- false --> cs4([retorna])\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 119.08617783774844,
                "y": -72.68711662770386
            },
            "zoom": 2.580872058868408,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718485302364,
        "type": "auto",
        "id": "ce0f7b75-cb4f-4bca-8a2e-c5a9b1d7ad00",
        "name": "cuddly-alarm"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            a2t --> a2t1([Fim])\n        a2 -- false --> a2f[define os pokemons atacante e defensor]\n            a2f -- mais_forte, mais_fraco --> a2f1[determina a força do ataque com base nos tipos]\n            a2f1 --> a2f2[calcula o hp a ser retirado do defensor]\n            a2f2 --> a2f3{o defensor foi derrotado?}\n            a2f3 -- true --> a2f3t[avança o contador de pokemon\n             atual do jogador defensor]\n                a2f3t --> a2f3t1[/Imprime qual pokemon venceu/]\n                a2f3t1 --> a2f4([retorna])\n            a2f3 -- false --> a2f4\n    end\n\n    subgraph checa_sobreviventes\n    direction TB\n        cs1[recebe o array de jogadores \n        e o índice do vencedor] --> cs2[inicializa um contador como o número\n         do pokemon atual do jogador vencedor]\n        cs2 --> cs3{o contador é menor do que a\n         quantidade de pokemons do vencedor?}\n        cs3 -- true --> cs3t[/Imprime o nome do pokemon/]\n        \n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 119.08617783774844,
                "y": -72.68711662770386
            },
            "zoom": 2.580872058868408,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718485242364,
        "type": "auto",
        "id": "98fa8904-4af4-4a4d-ba57-64a1e75299d3",
        "name": "bright-banana"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            a2t --> a2t1([Fim])\n        a2 -- false --> a2f[define os pokemons atacante e defensor]\n            a2f -- mais_forte, mais_fraco --> a2f1[determina a força do ataque com base nos tipos]\n            a2f1 --> a2f2[calcula o hp a ser retirado do defensor]\n            a2f2 --> a2f3{o defensor foi derrotado?}\n            a2f3 -- true --> a2f3t[avança o contador de pokemon\n             atual do jogador defensor]\n                a2f3t --> a2f3t1[/Imprime qual pokemon venceu/]\n                a2f3t1 --> a2f4([retorna])\n            a2f3 -- false --> a2f4\n    end\n\n    subgraph checa_sobreviventes\n    direction TB\n        cs1[recebe o array de jogadores \n        e o índice do vencedor] --> cs2[inicializa um contador como o número\n         do pokemon atual do jogador vencedor]\n        cs2 --> cs3{o contador é menor do que a}\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 119.08617783774844,
                "y": -72.68711662770386
            },
            "zoom": 2.580872058868408,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718485182373,
        "type": "auto",
        "id": "7071b649-e43e-48c4-b744-7f06a1a4c66e",
        "name": "full-ram"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            a2t --> a2t1([Fim])\n        a2 -- false --> a2f[define os pokemons atacante e defensor]\n            a2f -- mais_forte, mais_fraco --> a2f1[determina a força do ataque com base nos tipos]\n            a2f1 --> a2f2[calcula o hp a ser retirado do defensor]\n            a2f2 --> a2f3{o defensor foi derrotado?}\n            a2f3 -- true --> a2f3t[avança o contador de pokemon\n             atual do jogador defensor]\n                a2f3t --> a2f3t1[/Imprime qual pokemon venceu/]\n                a2f3t1 --> a2f4([retorna])\n            a2f3 -- false --> a2f4\n    end\n\n    subgraph checa_sobreviventes\n    direction TB\n        cs1[recebe o array de jogadores \n        e o índice do vencedor] --> cs2[inicializa um contador]\n        \n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 119.08617783774844,
                "y": -72.68711662770386
            },
            "zoom": 2.580872058868408,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718485122370,
        "type": "auto",
        "id": "9f9063b9-d7c1-4534-9379-96bdb8452560",
        "name": "narrow-traffic"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            a2t --> a2t1([Fim])\n        a2 -- false --> a2f[define os pokemons atacante e defensor]\n            a2f -- mais_forte, mais_fraco --> a2f1[determina a força do ataque com base nos tipos]\n            a2f1 --> a2f2[calcula o hp a ser retirado do defensor]\n            a2f2 --> a2f3{o defensor foi derrotado?}\n            a2f3 -- true --> a2f3t[avança o contador de pokemon\n             atual do jogador defensor]\n                a2f3t --> a2f3t1[/Imprime qual pokemon venceu/]\n                a2f3t1 --> a2f4([retorna])\n            a2f3 -- false --> a2f4\n    end\n\n    subgraph checa_sobreviventes\n    direction TB\n        \n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 119.08617783774844,
                "y": -72.68711662770386
            },
            "zoom": 2.580872058868408,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718485062370,
        "type": "auto",
        "id": "85ffb063-3a5f-4e04-8aa6-60414ebcc980",
        "name": "immense-magician"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            a2t --> a2t1([Fim])\n        a2 -- false --> a2f[define os pokemons atacante e defensor]\n            a2f -- mais_forte, mais_fraco --> a2f1[determina a força do ataque com base nos tipos]\n            a2f1 --> a2f2[calcula o hp a ser retirado do defensor]\n            a2f2 --> a2f3{o defensor foi derrotado?}\n            a2f3 -- true --> a2f3t[avança o contador de pokemon\n             atual do jogador defensor]\n                a2f3t --> a2f3t1[/Imprime qual pokemon venceu/]\n                a2f3t1 --> a2f4([retorna])\n            a2f3 -- false --> a2f4\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 135.96431814688765,
                "y": -368.8321374872634
            },
            "zoom": 3.5083374977111816,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718485002367,
        "type": "auto",
        "id": "2fb96224-5aa2-4e82-948e-94f30d9c9d1d",
        "name": "cold-optician"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            a2t --> a2t1([Fim])\n        a2 -- false --> a2f[define os pokemons atacante e defensor]\n            a2f -- mais_forte, mais_fraco --> a2f1[determina a força do ataque com base nos tipos]\n            a2f1 --> a2f2[calcula o hp a ser retirado do defensor]\n            a2f2 --> a2f3{o defensor foi derrotado?}\n            a2f3 -- true --> a2f3t[avança o contador de pokemon\n             atual do jogador defensor]\n                a2f3t --> a2f3t1[/Imprime qual pokemon venceu/]\n            a2f3 -- false --> a2f3f[]\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 135.96431814688765,
                "y": -368.8321374872634
            },
            "zoom": 3.5083374977111816,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718484942972,
        "type": "auto",
        "id": "aeb7e4fc-6f9e-4a75-baf2-8845e9269342",
        "name": "itchy-analyst"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            a2t --> a2t1([Fim])\n        a2 -- false --> a2f[define os pokemons atacante e defensor]\n            a2f -- mais_forte, mais_fraco --> a2f1[determina a força do ataque com base nos tipos]\n            a2f1 --> a2f2[calcula o hp a ser retirado do defensor]\n            a2f2 --> a2f3{o defensor foi derrotado?}\n            a2f3 -- true --> a2f3t[avança o contador de pokemon\n             atual do jogador defensor]\n                a2f3t --\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 135.96431814688765,
                "y": -368.8321374872634
            },
            "zoom": 3.5083374977111816,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718484882365,
        "type": "auto",
        "id": "df43ee92-dd15-4336-8514-b36d9e5087b6",
        "name": "dry-daughter"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            a2t --> a2t1([Fim])\n        a2 -- false --> a2f[define os pokemons atacante e defensor]\n            a2f -- mais_forte, mais_fraco --> a2f1[determina a força do ataque com base nos tipos]\n            a2f1 --> a2f2[calcula o hp a ser retirado do defensor]\n            a2f2 --> a2f3{o defensor foi derrotado?}\n            a2f3 -- true --> a2f3t[avança o contador de pokemon\n             atual do jogador defensor]\n            \n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 135.96431814688765,
                "y": -368.8321374872634
            },
            "zoom": 3.5083374977111816,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718484762368,
        "type": "auto",
        "id": "ee8efdc6-c1c0-4dd2-baa3-6eaf6587a530",
        "name": "enough-woman"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            a2t --> a2t1([Fim])\n        a2 -- false --> a2f[define os pokemons atacante e defensor]\n            a2f -- mais_forte, mais_fraco --> a2f1[determina a força do ataque com base nos tipos]\n            a2f1 --> a2f2[calcula o hp a ser retirado do defensor]\n            a2f2 --> a2f3{o defensor foi derrotado?}\n            a2f3 -- true --> a2f3t[avança o contador de pokemon atual do ]\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 135.96431814688765,
                "y": -368.8321374872634
            },
            "zoom": 3.5083374977111816,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718484582373,
        "type": "auto",
        "id": "0334ffab-0fea-4735-8191-09ea3d952d23",
        "name": "round-baker"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            a2t --> a2t1([Fim])\n        a2 -- false --> a2f[define os pokemons atacante e defensor]\n            a2f -- mais_forte, mais_fraco --> a2f1[determina a força do ataque com base nos tipos]\n            a2f1 --> a2f2[calcula o hp a ser retirado do defensor]\n            a2f2 --> a2f3{o defensor foi derrotado?}\n            a2f3 -- true --> a2f3t\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 135.96431814688765,
                "y": -368.8321374872634
            },
            "zoom": 3.5083374977111816,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718484462379,
        "type": "auto",
        "id": "9b1f445b-5b0e-4277-8938-3cf39475c1db",
        "name": "tender-yak"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            a2t --> a2t1([Fim])\n        a2 -- false --> a2f[define os pokemons atacante e defensor]\n            a2f -- mais_forte, mais_fraco --> a2f1[determina a força do ataque com base nos tipos]\n            a2f1 --> a2f2[calcula o hp a ser retirado do defensor]\n            a2f2 --> a2d3{o defensor foi derrotado?}\n            a2\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 135.96431814688765,
                "y": -368.8321374872634
            },
            "zoom": 3.5083374977111816,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718484402374,
        "type": "auto",
        "id": "7234e852-9f47-43a2-bb78-e0a4fafd044b",
        "name": "astonishing-tent"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            a2t --> a2t1([Fim])\n        a2 -- false --> a2f[define os pokemons atacante e defensor]\n            a2f -- mais_forte, mais_fraco --> a2f1[determina a força do ataque com base nos tipos]\n            a2f1 --> a2f2\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 135.96431814688765,
                "y": -368.8321374872634
            },
            "zoom": 3.5083374977111816,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718484342370,
        "type": "auto",
        "id": "bfa0c16b-b8c0-4b50-aa79-2039a69f62fc",
        "name": "shapely-church"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            a2t --> a2t1([Fim])\n        a2 -- false --> a2f[define os pokemons atacante e defensor]\n            a2f -- mais_forte, mais_fraco --> a2f1[determina a força do ataque com base nos tipos]\n            a2f1 -->\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 135.96431814688765,
                "y": -368.8321374872634
            },
            "zoom": 3.5083374977111816,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718484222377,
        "type": "auto",
        "id": "8d7706cf-f7f6-49a8-96f7-ac5a487153c8",
        "name": "aggressive-cpu"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            a2t --> a2t1([Fim])\n        a2 -- false --> a2f[define os pokemons atacante e defensor]\n            a2f -- mais_forte --> a2f1[determina a força do ataque com base nos tipos]\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 135.96431814688765,
                "y": -368.8321374872634
            },
            "zoom": 3.5083374977111816,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718483922967,
        "type": "auto",
        "id": "37077407-66b8-4f0e-8475-b8b248b9d52b",
        "name": "sour-night"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            a2t --> a2t1([Fim])\n        a2 -- false --> a2f[define os pokemons atacante e defensor]\n            a2f --> \n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 135.96431814688765,
                "y": -368.8321374872634
            },
            "zoom": 3.5083374977111816,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718483862373,
        "type": "auto",
        "id": "55de61d0-1d19-43db-9682-551acbe7051d",
        "name": "chilly-energy"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            a2t --> a2t1([Fim])\n        a2 -- false --> a2f[define o índice do defensor]\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 215.96434488961674,
                "y": -378.83210802668117
            },
            "zoom": 3.5083374977111816,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718483802647,
        "type": "auto",
        "id": "17eca7d8-3f43-4001-979d-e23800ce7466",
        "name": "raspy-hair"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            a2t --> a2t1([Fim])\n        a2 -- false --> a2f[define]\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 215.96434488961674,
                "y": -378.83210802668117
            },
            "zoom": 3.5083374977111816,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718483622969,
        "type": "auto",
        "id": "5345473e-cb9c-4e41-9164-80929dc71484",
        "name": "bewildered-spring"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            a2t --> a2t1([Fim])\n        a2 -- false --> a2f[cira]\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 215.96434488961674,
                "y": -378.83210802668117
            },
            "zoom": 3.5083374977111816,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718483562378,
        "type": "auto",
        "id": "a29044c7-00b9-4b3f-a856-a77380c2c400",
        "name": "callous-dentist"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            a2t --> a2t1([Fim])\n        a2 -- false --> a2f[]\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 215.96434488961674,
                "y": -378.83210802668117
            },
            "zoom": 3.5083374977111816,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718483442373,
        "type": "auto",
        "id": "3ccdb666-6dfd-4a7f-abcd-a52e1eb667d8",
        "name": "odd-lizard"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -- true --> a2t[/Imprimi/]\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 215.96434488961674,
                "y": -378.83210802668117
            },
            "zoom": 3.5083374977111816,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718483382378,
        "type": "auto",
        "id": "a32e7c07-6711-44ab-93af-5a525af8b560",
        "name": "jealous-butcher"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 --> a3\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 253.96442125091664,
                "y": -445.8320760924247
            },
            "zoom": 3.5083375445697578,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718483322971,
        "type": "auto",
        "id": "ea920c51-622a-481b-8cb5-b49a59933d72",
        "name": "beautiful-monitor"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 --> a3\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 169.14061176621362,
                "y": -0.7661428180076566
            },
            "zoom": 1.659959343593378,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718480922379,
        "type": "auto",
        "id": "b2dbcee1-0724-4b97-8acb-401f80aa1fe0",
        "name": "famous-flower"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 --> a3\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 169.14061176621362,
                "y": -0.7661428180076566
            },
            "zoom": 1.659959343593378,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718480890790,
        "type": "manual",
        "id": "8c0b2b1b-e2b2-4594-8a8c-ea812040553c",
        "name": "noisy-tiger"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2{o array é nulo ?}\n        a2 -->\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 115.92586893288512,
                "y": -71.96446780870971
            },
            "zoom": 2.089770555496216,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718480862371,
        "type": "auto",
        "id": "c3a7aff2-ad4d-4af9-a871-273790612a3a",
        "name": "warm-ambulance"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe uma linha] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe o array de jogadores e\n         o índice do atacante] --> a2[]\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 115.92586893288512,
                "y": -71.96446780870971
            },
            "zoom": 2.089770555496216,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718480802364,
        "type": "auto",
        "id": "1807b25d-c029-40de-b593-27b5c2283273",
        "name": "uninterested-grass"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1[recebe um] --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2f\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end\n\n    subgraph ataca\n    direction TB\n        a1[recebe]\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": -342.0740186919749,
                "y": 89.03554915634669
            },
            "zoom": 2.089770555496216,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718480742364,
        "type": "auto",
        "id": "cf297ea5-c0c4-444b-b00e-4d63c1e53bff",
        "name": "chilly-lamp"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n                i2ft1 --> i2\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função 'pause' e retorna])\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 78.10301449076691,
                "y": -369.7403439549601
            },
            "zoom": 2.531820297241211,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718480682367,
        "type": "auto",
        "id": "e990bb8a-c9ec-4b25-aca3-2d645cc75337",
        "name": "helpful-cpu"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n            i2f -- false --> i2ff[checa quem venceu e os sobreviventes]\n            i2ff -- checa_sobreviventes --> i2ff1[checa os derrotados]\n            i2ff1 -- checa_derrotados --> i2ff2([chama a função \"pause\"])\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 338.6276918696258,
                "y": -97.2043401026204
            },
            "zoom": 1.799275517463684,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718480622369,
        "type": "auto",
        "id": "7237be5a-321b-4451-94ba-8df728c96e99",
        "name": "small-soccer"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n            i2f -- false --> i2ff[checa quem venceu]\n            i2ff -- checa_sobreviventes, checa_derrotados --> i2ff1[checa os sorbeviventes, derrotados]\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 338.6276918696258,
                "y": -97.2043401026204
            },
            "zoom": 1.799275517463684,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718480562372,
        "type": "auto",
        "id": "71fe842a-872b-4285-99a9-2a6f60bba4b2",
        "name": "best-accountant"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n            i2f -- false --> i2ff[checa quem venceu e os ]\n            i2ff -- checa_sobreviventes\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 338.6276918696258,
                "y": -97.2043401026204
            },
            "zoom": 1.799275517463684,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718480502367,
        "type": "auto",
        "id": "80ec61a3-7f9e-4e0c-9211-d398b8d99112",
        "name": "dirty-hairdresser"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> i2f{há pokemons restantes nos dois times?}\n            i2f -- true --> i2ft[chama a função ataca]\n                i2ft -- ataca --> i2ft1[troca o lado atacante]\n            \n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 338.6276918696258,
                "y": -97.2043401026204
            },
            "zoom": 1.799275517463684,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718480442378,
        "type": "auto",
        "id": "a706faad-6cb7-4267-8298-1c58cdcad5b1",
        "name": "savory-train"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n        i2 -- false --> t2f{há pokemons restantes nos dois times?}\n            i2f -- true --> t2ft[]\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 479.62768339674386,
                "y": -110.20430872515286
            },
            "zoom": 1.799275517463684,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718480382970,
        "type": "auto",
        "id": "55ec3fa6-f36d-4ce6-82cf-ca957942282c",
        "name": "ashamed-death"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe o array de jogadores] --> i2{o array é nulo?}\n        i2 -- true --> t2t[/Imprime: Erro: jogadores é um ponteiro nulo./]\n            t2t --> t2t1([Fim])\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 479.62768339674386,
                "y": -110.20430872515286
            },
            "zoom": 1.799275517463684,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718480322378,
        "type": "auto",
        "id": "26a7376f-3279-4401-8e79-af4a52397081",
        "name": "savory-gpu"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end\n\n    subgraph inicia_jogo\n    direction TB\n        i1[recebe os dados passados] --> i2{os dados}\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 577.6276864168507,
                "y": -103.20427097356963
            },
            "zoom": 1.799275517463684,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718480262371,
        "type": "auto",
        "id": "df0cb661-1c45-4042-a558-ec6a62858cb8",
        "name": "melted-television"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2[libera a memória alocada]\n                m1f1f2 --> m1f1f3([encerra o programa])\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": -6.372401741729107,
                "y": -320.20431980812333
            },
            "zoom": 1.7992755215454843,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718480202365,
        "type": "auto",
        "id": "12561b39-c847-4ee1-aa01-a00819224b67",
        "name": "putrid-translator"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1[inicia a simulação]\n                m1f1f1 -- inicia_jogo --> m1f1f2\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": -1726.7539667345466,
                "y": -391.39527627577286
            },
            "zoom": 2.3077785968780518,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718480142365,
        "type": "auto",
        "id": "48d2ec4b-8f65-4004-94f4-7ff60ed40b93",
        "name": "low-magazine"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": -482.35854895758666,
                "y": -142.7443035800908
            },
            "zoom": 1.6128934546339924,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718480082972,
        "type": "auto",
        "id": "b5fcf9e3-9679-4e63-9f0a-a86f8ff68565",
        "name": "many-ocean"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2ff1f3 --> d2f2\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 39.43585669098468,
                "y": -264.9166027522437
            },
            "zoom": 1.741563677787781,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718480022372,
        "type": "auto",
        "id": "faf2b868-c7cb-449e-aa31-100f734d06d3",
        "name": "long-book"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n                        d2f2ff1f2 --> d2f2ff1f3[avança o contador de palavras]\n                        d2f2\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": -50.73552667376215,
                "y": -483.8635397414876
            },
            "zoom": 2.206573247909546,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718479962375,
        "type": "auto",
        "id": "9e4dc481-68a4-4e66-bda6-8bc95c5e7d5b",
        "name": "repulsive-fish"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": -46.80413336157194,
                "y": -288.14799222887143
            },
            "zoom": 2.206573009490967,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718479902364,
        "type": "auto",
        "id": "68379457-41f5-4871-a0f7-529caee6ebee",
        "name": "adorable-pilot"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor \n                         com '\\0' na última posição]\n                        d2f2ff1f1 --> d2f2ff1f2[avança o ponteiro de início para o endereço do de fim]\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 83.3291846768707,
                "y": -174.55663816952872
            },
            "zoom": 1.6284419298171997,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718479842971,
        "type": "auto",
        "id": "c334c61a-7b16-4a3e-a1bc-1f2ebed8eb02",
        "name": "embarrassed-guitar"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1f --> d2f2ff1f1[copia a palavra para o vetor com '\\0' na ]\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 83.3291846768707,
                "y": -174.55663816952872
            },
            "zoom": 1.6284419298171997,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718479782374,
        "type": "auto",
        "id": "8e95ea5a-8642-4d61-a29c-4e29924d9fe3",
        "name": "happy-artist"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false --> d2f2ff1f[aloca memória para a palavra encontrada]\n                        d2f2ff1t --> d2f2\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 63.329101803393655,
                "y": -50.556619213043284
            },
            "zoom": 1.6284419298171997,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718479722512,
        "type": "auto",
        "id": "01ad9f75-10c5-48b2-adb7-1b3b258a7e59",
        "name": "greasy-banana"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente \n                    de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n                        d2f2ff1t --> d2f2ff1\n                    d2f2ff1 -- false -->\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 63.329101803393655,
                "y": -50.556619213043284
            },
            "zoom": 1.6284419298171997,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718479662367,
        "type": "auto",
        "id": "a3cd7747-b9f4-4573-859d-57f24a022db5",
        "name": "sharp-guitar"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é diferente de um espaço ou '\\0' ?}\n                    d2f2ff1 -- true --> d2f2ff1t[avança o ponteiro de fim]\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": -21.134982514611437,
                "y": -355.210695138792
            },
            "zoom": 2.237685441970825,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718479602576,
        "type": "auto",
        "id": "e5bb7c6d-cc0d-4bf2-ad42-8aa8551363d3",
        "name": "microscopic-camera"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                    d2f2ft --> d2f2f\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{o ponteiro de fim é }\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 26.865056507639657,
                "y": -269.2107025737826
            },
            "zoom": 2.237685441970825,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718479542973,
        "type": "auto",
        "id": "918bf2dc-c964-4bd9-88ef-600697012ef9",
        "name": "yummy-australia"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                d2f2f -- false --> d2f2ff[inicializamos o ponteiro de fim\n                 como igual ao de início]\n                    d2f2ff --> d2f2ff1{}\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 47.63509051442703,
                "y": -4.620401704101745
            },
            "zoom": 1.980393171310425,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718479482364,
        "type": "auto",
        "id": "7ee13574-b2cd-4fb4-b4ed-77cc40627a79",
        "name": "scary-actor"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                d2f2f -- false --> d2f2ff[a]\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 47.63509051442703,
                "y": -4.620401704101745
            },
            "zoom": 1.9803931381098716,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718479422968,
        "type": "auto",
        "id": "5b268bec-00b2-4591-9450-f94c36344f53",
        "name": "abrasive-telephone"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[avança o ponteiro de início]\n                d2f2f -- false --> d2f2ff[a]\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 124.20938185927943,
                "y": 108.91345757488733
            },
            "zoom": 1.5221741199493408,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718478882364,
        "type": "auto",
        "id": "ce1c1224-815d-474a-9cb9-e67a70fd662c",
        "name": "tart-disease"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d2f2 -- false --> d2f2f{o ponteiro de início \n            é um espaço em branco?}\n                d2f2f -- true --> d2f2ft[]\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 124.20938185927943,
                "y": 108.91345757488733
            },
            "zoom": 1.5221741199493408,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718478822374,
        "type": "auto",
        "id": "34b47757-1cce-472a-b8d5-a7e2d5de4b52",
        "name": "silly-wolf"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 -- true --> d2f2t[anula a última posição do vetor]\n                d2f2t --> d2f2t1([retorna o array de palavras])\n            d\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 124.20938185927943,
                "y": 108.91345757488733
            },
            "zoom": 1.5221741199493408,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718478762730,
        "type": "auto",
        "id": "bc68cc27-0f12-4ae8-8964-10a3ed1d7021",
        "name": "flat-finland"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n            d2f --> d2f1[inicializa ponteiros para o início e fim de cada palavra]\n            d2f1 --> d2f2{o ponteiro de início é nulo?}\n            d2f2 --\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 124.20938185927943,
                "y": 108.91345757488733
            },
            "zoom": 1.5221741199493408,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718478702366,
        "type": "auto",
        "id": "e0f74dc1-00db-4b3d-a43f-cadc76eca0a7",
        "name": "savory-printer"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida./]\n            d2t --> d2t1([Fim])\n        d2 -- false --> d2f[aloca memória para um array de palavras]\n        d2f --> d2f1[inicializa ponteiros para]\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 124.20938185927943,
                "y": 108.91345757488733
            },
            "zoom": 1.5221741199493408,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718478642387,
        "type": "auto",
        "id": "f99e18b4-4765-4143-865f-d681f098fc75",
        "name": "deep-energy"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 --> d2{a linha é nula?}\n        d2 -- true --> d2t[/Imprime: Cadeia de caracteres inválida :(vazia ou nula)./]\n        d2t --> d2t1([Fim])\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 153.01669393003777,
                "y": 95.0354838238892
            },
            "zoom": 1.1697455644607544,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718478582374,
        "type": "auto",
        "id": "f61e5880-dc04-49a0-9f1b-32898b7f72ae",
        "name": "belligerent-denmark"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe os dados do arquivo lido] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 --> d2{}\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 152.01670660668955,
                "y": 95.0354838238892
            },
            "zoom": 1.1697455644607544,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718478522368,
        "type": "auto",
        "id": "c4cbc970-6cf3-4c31-9d69-d8953bff7731",
        "name": "miniature-wolf"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1[recebe um nome de arquivo] --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1[recebe ] --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end\n\n    subgraph divide_linha\n    direction TB\n        d1 -->\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 55.10741910617179,
                "y": 116.83764736630457
            },
            "zoom": 0.8839271295966049,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718478462367,
        "type": "auto",
        "id": "a911b557-d7f5-43db-afce-9af2d1d0a444",
        "name": "powerful-electrician"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1 --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{a linha é nula?}\n            c4 -- true --> c4t([retorna o array de jogadores])\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 29.052677990964924,
                "y": -91.69296275797765
            },
            "zoom": 1.4847544431686401,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718478402371,
        "type": "auto",
        "id": "e79555db-868a-4bb0-85df-2f55f11174ea",
        "name": "slimy-eventide"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retorna a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1 --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{token é nulo?}\n            c4 -- true --> c4t[a]\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4f1[avança nas linhas]\n            c4ff2 --> c4f1\n            c4f1 --> c4\n        c4 --> c5([retorna])\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 61.2026973386502,
                "y": -73.15587968713596
            },
            "zoom": 1.2734777927398682,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718478342364,
        "type": "auto",
        "id": "6cf91054-3cc0-4c5f-8259-897358f8d72a",
        "name": "pitiful-engineer"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retornamos a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1 --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{token é nulo?}\n            c4 -- true --> c4t[a]\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> c4ff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                c4ff1 --> c4ff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c5[avança nas linhas]\n            c4ff2 --> c5\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 61.2026973386502,
                "y": -73.15587968713596
            },
            "zoom": 1.2734777927398682,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718478282368,
        "type": "auto",
        "id": "f6da3c49-ea76-4a7e-81f1-1e37f70b76c1",
        "name": "nutritious-printer"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retornamos a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1 --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{token é nulo?}\n            c4 -- true --> c4t[a]\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> caff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                caff1 --> caff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n            c4ft2 --> c4\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 61.2026973386502,
                "y": -73.15587968713596
            },
            "zoom": 1.2734777927398682,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718478222364,
        "type": "auto",
        "id": "e79696b9-3af1-4d75-b092-f4562a24bd64",
        "name": "bitter-van"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retornamos a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1 --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{token é nulo?}\n            c4 -- true --> c4t[a]\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> caff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                caff1 --> caff2[com o array retornado, povoa um novo pokemon \n                e o coloca no deck do jogador atual]\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 61.2026973386502,
                "y": -73.15587968713596
            },
            "zoom": 1.273477784138524,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718478162377,
        "type": "auto",
        "id": "1999ee7c-bbc9-40b7-a1fd-a1751f84f191",
        "name": "brown-book"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retornamos a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1 --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{token é nulo?}\n            c4 -- true --> c4t[a]\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> caff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                caff1 --> caff2[com o array retornado ]\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 210.37502753602794,
                "y": 76.57512005292759
            },
            "zoom": 0.8023161888122559,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718478102375,
        "type": "auto",
        "id": "038d77d4-facf-4ba2-bb49-642473c90b79",
        "name": "proud-tomato"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retornamos a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1 --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{token é nulo?}\n            c4 -- true --> c4t[a]\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> caff1[define qual jogador e pokemon está sendo \n                criado com base em contadores]\n                \n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 66.91860949626174,
                "y": -96.93693681775159
            },
            "zoom": 1.124865174293518,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718478068774,
        "type": "manual",
        "id": "5bf3ec8f-fc79-4793-b716-b86a12ac4fdb",
        "name": "broad-van"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retornamos a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1 --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{token é nulo?}\n            c4 -- true --> c4t[a]\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divide a linha em palavras]\n                c4ff -- divide_linha --> caff1[define qual jogador está sendo criado com base em contadores]\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 66.91860949626174,
                "y": -96.93693681775159
            },
            "zoom": 1.124865174293518,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718478042366,
        "type": "auto",
        "id": "74f77a7c-1a11-4ab5-8bbe-533ec6626898",
        "name": "delightful-caravan"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retornamos a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1 --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{token é nulo?}\n            c4 -- true --> c4t[a]\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4ft1[lê a quantidade de pokemons de cada jogador]\n                    c4ft1 --> c4ft2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4ff[divi]\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 66.91860949626174,
                "y": -96.93693681775159
            },
            "zoom": 1.124865174293518,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718477982364,
        "type": "auto",
        "id": "077fb8ac-8acb-4c5a-82c2-d5086bbd5c43",
        "name": "wailing-action"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retornamos a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1 --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{token é nulo?}\n            c4 -- true --> c4t[a]\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4f1[lê a quantidade de pokemons de cada jogador]\n                    c4f1 --> c4f2[aloca o array de pokemons de cada jogador]\n                c4f -- false --> c4f1[a]\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 66.91860949626174,
                "y": -96.93693681775159
            },
            "zoom": 1.124865174293518,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718477922365,
        "type": "auto",
        "id": "fa9ea9a1-2979-4533-87e4-4f06afa38382",
        "name": "quaint-eve"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retornamos a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1 --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{token é nulo?}\n            c4 -- true --> c4t[a]\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -- true --> c4f1[lê a quantidade de pokemons de cada jogador]\n                c4f1 --> c4f2[aloca o array de pokemons de cada jogador]\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "pan": {
                "x": 66.91860949626174,
                "y": -96.93693681775159
            },
            "zoom": 1.124865174293518,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718477862967,
        "type": "auto",
        "id": "6f042d67-c262-454c-8cff-f8c02f71adfd",
        "name": "miniature-nurse"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retornamos a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1 --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{token é nulo?}\n            c4 -- true --> c4t[a]\n            c4 -- false --> c4f{é a primeira linha?}\n                c4f -\n\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 66.91860949626174,
                "y": -96.93693681775159
            },
            "zoom": 1.124865174293518,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718477802378,
        "type": "auto",
        "id": "f85398db-168b-4b12-8edd-1f4131f9131a",
        "name": "modern-printer"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retornamos a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1 --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas usando strtok]\n        c3 --> c4{token é nulo?}\n        c4 -- true --> c4t[]\n        c4 -- false --> c4f[]\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 66.91860949626174,
                "y": -96.93693681775159
            },
            "zoom": 1.124865174293518,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718477742968,
        "type": "auto",
        "id": "77259b81-c4c2-418c-83ba-7eb2557962da",
        "name": "colossal-whale"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retornamos a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1 --> c2[aloca memória para a array de estruturar TJogador]\n        c2 --> c3[divide os dados recebidos em linhas]\n        c3 --> c4{}\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 66.91860949626174,
                "y": -96.93693681775159
            },
            "zoom": 1.124865174293518,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718477682365,
        "type": "auto",
        "id": "725fa3c0-16db-432c-909b-d61a7f96d97f",
        "name": "miniature-fountain"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retornamos a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    direction TB\n        c1 --> c2[aloca memória para a array de estruturar Tjo]\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 66.91860949626174,
                "y": -96.93693681775159
            },
            "zoom": 1.124865174293518,
            "editorMode": "code",
            "panZoom": true
        },
        "time": 1718477622379,
        "type": "auto",
        "id": "1322e649-a4d4-4ff5-b4a9-0e3ac780ee35",
        "name": "yummy-area"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f -- cria_jogadores --> m1f1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{contador < num_tot_poks}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retornamos a string com todos os dados])\n    end\n\n    subgraph cria_jogadores\n    d",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718477562366,
        "type": "auto",
        "id": "3ee1636e-2c1e-49a5-a6fc-0e326f67680a",
        "name": "aloof-laptop"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[/Imprime os dados lidos/]\n                m1f1f --> m1f1f1 -- cra_jogadores --> f\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{\"`contador **i** < num_tot_poks`\"}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retornamos a string com todos os dados])\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718477502377,
        "type": "auto",
        "id": "1cba8e2e-8743-4b5d-aba2-b4d95c1da5de",
        "name": "wide-receptionist"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t[/Imprime: Erro ao ler arquivo/]\n                m1f1t --> m1f1t1([Fim])\n            m1f1 -- false --> m1f1f[]\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{\"`contador **i** < num_tot_poks`\"}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retornamos a string com todos os dados])\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718477442370,
        "type": "auto",
        "id": "2f278091-d3aa-486d-8440-c11938337def",
        "name": "thoughtless-agent"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{a string retornada é nula?}\n            m1f1 -- true --> m1f1t{Imprime: Erro ao ler arquivo/]\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{\"`contador **i** < num_tot_poks`\"}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retornamos a string com todos os dados])\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718477382366,
        "type": "auto",
        "id": "bbd9046a-b512-434a-8ea5-c6a0dbe3ad86",
        "name": "gray-finland"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1{se}\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{\"`contador **i** < num_tot_poks`\"}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retornamos a string com todos os dados])\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718477322399,
        "type": "auto",
        "id": "862bdd03-b898-4749-a15d-e89b49a438f8",
        "name": "quick-rose"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> l1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{\"`contador **i** < num_tot_poks`\"}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retornamos a string com todos os dados])\n        l3f1f1 --> m1f\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718477262374,
        "type": "auto",
        "id": "3fe9e89a-e124-489a-b150-d52612d37f98",
        "name": "plump-ocean"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1\n    end\n\n    subgraph le_arquivo\n    direction \n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{\"`contador **i** < num_tot_poks`\"}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1([retornamos a string com todos os dados])\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718477202373,
        "type": "auto",
        "id": "dc10d529-5882-4e7a-9c15-631898161789",
        "name": "dry-agency"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{\"`contador **i** < num_tot_poks`\"}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1t3[concatena os dados à string a ser retornada]\n            l3f1t3 --> l3f1\n        l3f1 -- false --> l3f1f1[a]\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718477142367,
        "type": "auto",
        "id": "b431b46a-3624-44d7-9422-e4d41875e337",
        "name": "repulsive-baker"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{\"`contador **i** < num_tot_poks`\"}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon lido]\n            l3f1t2 --> l3f1\n        l3f1 -- false --> l3f1f1[a]\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718477082970,
        "type": "auto",
        "id": "c363b43d-61af-4175-867f-6610398313b0",
        "name": "big-coat"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1\n    end\n\n    subgraph le_arquivo\n    direction TB\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{\"`contador **i** < num_tot_poks`\"}\n        l3f1 -- true --> l3f1t1[lê a próxima linha]\n            l3f1t1 --> l3f1t2[armazena os dados do pokemon l]\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718477023506,
        "type": "auto",
        "id": "a6debe35-c96b-465e-9b2d-3e6d2992723a",
        "name": "petite-article"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1\n    end\n\n    subgraph le_arquivo\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{\"`contador **i** < num_tot_poks`\"}\n        l3f1 -- true --> l3f1t1[]\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718476962380,
        "type": "auto",
        "id": "783e8e45-c0f3-494e-ba22-c1bae5016314",
        "name": "beautiful-painting"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1\n    end\n\n    subgraph le_arquivo\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --> l3f1{\"`contador **i** < num_tota`\"}\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718476902378,
        "type": "auto",
        "id": "cf197870-62b1-4ace-a8f6-d3665cb04097",
        "name": "lively-jelly"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1\n    end\n\n    subgraph le_arquivo\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[lê a primeira linha, \n        recebendo o nº de pokemons de cada jogador]\n        l3f --\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718476842373,
        "type": "auto",
        "id": "529f0e67-f772-4871-8cba-4fb00b1af4a2",
        "name": "savory-wire"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1\n    end\n\n    subgraph le_arquivo\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1([Fim])\n        l3 -- false --> l3f[a]\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718476782367,
        "type": "auto",
        "id": "8cab4bcc-4c5c-4558-a610-dbb2c98ec187",
        "name": "helpful-morn"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m1f1\n    end\n\n    subgraph le_arquivo\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: Erro ao abrir arquivo/] --> l3t1()\n        l3 -- false --> l3f[a]\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718476722371,
        "type": "auto",
        "id": "97e55d48-fd3a-49b5-9ff2-90e7c5b6983d",
        "name": "wooden-london"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m1t[b]\n            \n        m1 -- false --> m1f[/Pede nome do arquivo para o usuário/]\n            m1f -- le_arquivo --> m2\n    end\n\n    subgraph le_arquivo\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[/Imprime: /]\n        l3 -- false --> l3f[a]\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718476662670,
        "type": "auto",
        "id": "2a96b3ef-19ba-4ec2-ad55-0297aab3889e",
        "name": "square-coffeeshop"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m2[b]\n            \n        m1 -- false --> m3[/Pede nome do arquivo para o usuário/]\n            m3 -- le_arquivo --> m4\n    end\n\n    subgraph le_arquivo\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l2 --> l3{arquivo nulo?}\n        l3 -- true --> l3t[]\n        l3\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718476602378,
        "type": "auto",
        "id": "1de225a2-398b-453c-9499-2c5cd49ed323",
        "name": "acceptable-island"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        m1{arquivo de entrada informado?} -- true --> m2[b]\n            \n        m1 -- false --> m3[/Pede nome do arquivo para o usuário/]\n            m3 -- le_arquivo --> m4\n    end\n\n    subgraph le_arquivo\n        l1 --> l2[abre o arquivo em modo de leitura]\n        l3 --> l4[a]\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718476542378,
        "type": "auto",
        "id": "97313a89-ee85-4839-a96a-9e6f683de601",
        "name": "breezy-country"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        a{arquivo de entrada informado?} -- true --> b[b]\n            \n        a -- false --> c[/Pede nome do arquivo para o usuário/]\n            c -- le_arquivo --> d\n    end\n\n    subgraph le_arquivo\n        d --> e[abre o a]\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718476482365,
        "type": "auto",
        "id": "b0c0455e-a0d8-49f1-bead-b9ad6c5c5819",
        "name": "fit-fish"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        a{arquivo de entrada informado?} -- true --> b[b]\n            \n        a -- false --> c[/Pede nome do arquivo para o usuário/]\n            c -- le_arquivo --> d\n    end\n\n    subgraph le_arquivo\n    ",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718476422365,
        "type": "auto",
        "id": "a1cd80d9-fcb7-4e6f-b52f-8f3a6d948baf",
        "name": "puny-country"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        a{arquivo de entrada informado?} -- true --> b[b]\n            \n        a -- false --> c[/Pede nome do arquivo para o usuário/]\n            c -- le_arquivo-->\n    end\n",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718476362379,
        "type": "auto",
        "id": "c171c886-d348-4073-aefe-b14da005a1b8",
        "name": "stale-dusk"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n    direction TB\n        a{arquivo de entrada informado?} -- true --> b[]\n            b\n        a -- false --> c[c]\n    end\n",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718476302364,
        "type": "auto",
        "id": "d7721736-031b-401f-9dbe-fa0b5cc9d9a5",
        "name": "howling-ambulance"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n        a{arquivo informado?} -- true --> b[b]\n        a -- false --> c[c]\n    end\n",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718476242367,
        "type": "auto",
        "id": "832f3fd5-24fa-4196-9adb-1eaba4e5627a",
        "name": "easy-library"
    },
    {
        "state": {
            "code": "flowchart TB\n    \n        main --> le_arquivo\n        le_arquivo --> verifica_arquivo\n        main --> cria_jogadores\n        main --> inicia_jogo\n\n        inicia_jogo --> A{há pokemons vivos \n        nos dois times?}\n        A -- true --> B[b]\n        A -- false --> C[c]\n",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718476182365,
        "type": "auto",
        "id": "b72b50df-ba30-4fa7-861f-2e373ab51ec7",
        "name": "prickly-carpenter"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n        main --> le_arquivo\n        le_arquivo --> verifica_arquivo\n        main --> cria_jogadores\n        main --> inicia_jogo\n    end\n    subgraph inicia_jogo\n        direction TB\n        inicia_jogo --> A{há pokemons vivos \n        nos dois times?}\n        A -- true --> B[b]\n        A -- false --> C[c]\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718476122966,
        "type": "auto",
        "id": "40549244-748b-4d0b-9f09-9c5cd4d5152f",
        "name": "hot-honey"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main\n        \n        main --> le_arquivo\n        le_arquivo --> verifica_arquivo\n        main --> cria_jogadores\n        main --> inicia_jogo\n    end\n    subgraph inicia_jogo\n        direction TB\n        inicia_jogo --> A{há pokemons vivos \n        nos dois times?}\n        A -- true --> B[b]\n        A -- false --> C[c]\n    end\n    \n    cria_jogadores --> classifica_pokemon\n    cria_jogadores --> divide_linha\n    inicia_jogo --> checa_derrotados\n    inicia_jogo --> ataca\n    ataca --> mais_forte\n    ataca --> mais_fraco",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718476062379,
        "type": "auto",
        "id": "f7fd2ea1-e04a-46c4-b06a-8dee0371d8ef",
        "name": "orange-ambulance"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main \n        main --> le_arquivo\n        le_arquivo --> verifica_arquivo\n        main --> cria_jogadores\n        main --> inicia_jogo\n    end\n    subgraph inicia_jogo\n        inicia_jogo --> A{há pokemons vivos nos dois times?}\n        A -- true --> B\n        A --\n    end\n    \n    cria_jogadores --> classifica_pokemon\n    cria_jogadores --> divide_linha\n    inicia_jogo --> checa_derrotados\n    inicia_jogo --> ataca\n    ataca --> mais_forte\n    ataca --> mais_fraco",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718476002364,
        "type": "auto",
        "id": "8337e232-11ba-45c9-beae-f9ab3bf7774e",
        "name": "acidic-city"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main \n        main --> le_arquivo\n        le_arquivo --> verifica_arquivo\n        main --> cria_jogadores\n        main --> inicia_jogo\n    end\n    subgraph inicia_jogo\n        inicia_jogo --> A{a}\n    end\n    \n    cria_jogadores --> classifica_pokemon\n    cria_jogadores --> divide_linha\n    inicia_jogo --> checa_derrotados\n    inicia_jogo --> ataca\n    ataca --> mais_forte\n    ataca --> mais_fraco",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718475942366,
        "type": "auto",
        "id": "9deaed09-1945-403f-ae79-f84afba4b208",
        "name": "easy-hydrogen"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main \n        main --> le_arquivo\n        le_arquivo --> verifica_arquivo\n        main --> cria_jogadores\n        main --> inicia_jogo\n    end\n    subgraph inicia_jogo\n        inicia_jogo --> if_{a}\n    end\n    \n    cria_jogadores --> classifica_pokemon\n    cria_jogadores --> divide_linha\n    inicia_jogo --> checa_derrotados\n    inicia_jogo --> ataca\n    ataca --> mais_forte\n    ataca --> mais_fraco",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718475882377,
        "type": "auto",
        "id": "636d21a6-200b-4eac-b726-45b5e8542b9d",
        "name": "teeny-hairdresser"
    },
    {
        "state": {
            "code": "flowchart TB\n    subgraph main \n        main --> le_arquivo\n        le_arquivo --> verifica_arquivo\n        main --> cria_jogadores\n        main --> inicia_jogo\n    end\n    subgraph\n    \n    cria_jogadores --> classifica_pokemon\n    cria_jogadores --> divide_linha\n    inicia_jogo --> checa_derrotados\n    inicia_jogo --> checa_sobreviventes\n    checa_sobreviventes --> ataca\n    ataca --> mais_forte\n    ataca --> mais_fraco",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718475822366,
        "type": "auto",
        "id": "d2349f66-9258-42f0-8d1e-5d18ee4699b8",
        "name": "icy-russia"
    },
    {
        "state": {
            "code": "flowchart TB\n    main --> le_arquivo -->\n    main --> cria_jogadores\n    main --> inicia_jogo\n    cria_jogadores --> classifica_pokemon\n    cria_jogadores --> divide_linha\n    inicia_jogo --> checa_derrotados\n    inicia_jogo --> checa_sobreviventes\n    checa_sobreviventes --> ataca\n    ataca --> mais_forte\n    ataca --> mais_fraco",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718475762368,
        "type": "auto",
        "id": "ecb29598-bf4e-4d21-9a5b-75150ae10239",
        "name": "millions-byte"
    },
    {
        "state": {
            "code": "flowchart TB\n    main --> cria_jogadores\n    main --> cria_log\n    main --> le_arquivo\n    main --> inicia_jogo\n    cria_jogadores --> classifica_pokemon\n    cria_jogadores --> divide_linha\n    inicia_jogo --> checa_derrotados\n    inicia_jogo --> checa_sobreviventes\n    checa_derrotados --> grava_arquivo\n    checa_sobreviventes --> ataca\n    ataca --> mais_forte\n    ataca --> mais_fraco\n    grava_arquivo --> verifica_arquivo",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718475702364,
        "type": "auto",
        "id": "59e73862-c3a6-4b8b-a6fa-38649f00b6d3",
        "name": "mammoth-morning"
    },
    {
        "state": {
            "code": "flowchart TB\n    A[main]",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718475642370,
        "type": "auto",
        "id": "3dbe38ea-a242-43b9-bec8-2f45fdcb5a02",
        "name": "helpless-queen"
    },
    {
        "state": {
            "code": "flowchart TB\n    A[Início] --> B[/Recebe o nome do arquivo de entrada/]\n    subgraph main\n        direction LR\n        B -- le_arquivo --> C[\"`Lê o arquivo linha a linha\n        Salva os dados em um array de strings\n        `\"]\n    end\n    subgraph inicia_jogo\n        direction LR\n        D -- cria_jogadores --> E[\"`Cria os jogadores e seus pokemons,\n        inicializando os seus atributos(nome, hp, atk, def, tipo)\n        `\"]\n        E -- inicia_jogo --> F[Enquanto houverem sobreviventes]\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718475582969,
        "type": "auto",
        "id": "677cdd51-57d2-4000-9a94-55db55c3d939",
        "name": "easy-battery"
    },
    {
        "state": {
            "code": "flowchart TB\n    A[Início] --> B[/Recebe o nome do arquivo de entrada/]\n    subgraph main\n        direction LR\n        B -- le_arquivo --> C[\"`Lê o arquivo linha a linha\n        Salva os dados em um array de strings\n        `\"]\n    end\n    C --> D\n    subgraph inicia_jogo\n        direction LR\n        D -- cria_jogadores --> E[\"`Cria os jogadores e seus pokemons,\n        inicializando os seus atributos(nome, hp, atk, def, tipo)\n        `\"]\n        E -- inicia_jogo --> F[Enquanto houverem sobreviventes]\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718475522373,
        "type": "auto",
        "id": "25492925-bd75-4219-a0d3-5413992a6abf",
        "name": "acidic-rainbow"
    },
    {
        "state": {
            "code": "flowchart TB\n    A[Início] --> B[/Recebe o nome do arquivo de entrada/]\n    subgraph main\n        direction LR\n        B -- le_arquivo --> C[\"`Lê o arquivo linha a linha\n        Salva os dados em um array de strings\n        `\"]\n    end\n    subgraph inicia_jogo\n        direction LR\n        C -- cria_jogadores --> D[\"`Cria os jogadores e seus pokemons,\n        inicializando os seus atributos(nome, hp, atk, def, tipo)\n        `\"]\n        D -- inicia_jogo --> E[Enquanto houverem sobreviventes]\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718475102962,
        "type": "auto",
        "id": "94a4f368-eb66-40a7-a7c9-561895b27de8",
        "name": "acrid-argument"
    },
    {
        "state": {
            "code": "flowchart TB\n    A[Início] -- main --> B[/Recebe o nome do arquivo de entrada/]\n    subgraph main\n        direction LR\n        B -- le_arquivo --> C[\"`Lê o arquivo linha a linha\n        Salva os dados em um array de strings\n        `\"]\n    end\n    subgraph inicia_jogo\n    direction RL\n        C -- cria_jogadores --> D[\"`Cria os jogadores e seus pokemons,\n        inicializando os seus atributos(nome, hp, atk, def, tipo)\n        `\"]\n        D -- inicia_jogo --> E[Enquanto houverem sobreviventes]\n    end",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718475042371,
        "type": "auto",
        "id": "a7cda715-c9c3-45a0-b72e-acb741733015",
        "name": "brief-dress"
    },
    {
        "state": {
            "code": "flowchart TD\n    A[Início] -- main --> B[/Recebe o nome do arquivo de entrada/]\n    subgraph one\n        direction LR\n        B -- le_arquivo --> C[\"`Lê o arquivo linha a linha\n        Salva os dados em um array de strings\n        `\"]\n    end\n    C -- cria_jogadores --> D[\"`Cria os jogadores e seus pokemons,\n    inicializando os seus atributos(nome, hp, atk, def, tipo)\n    `\"]\n    D -- inicia_jogo --> E[Enquanto houverem sobreviventes]",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718474982960,
        "type": "auto",
        "id": "3891ff74-fadc-4c45-8a6c-24115cd96727",
        "name": "kind-agent"
    },
    {
        "state": {
            "code": "flowchart TD\n    A[Início] -- main --> B[/Recebe o nome do arquivo de entrada/]\n    subgraph one\n    B -- le_arquivo --> C[\"`Lê o arquivo linha a linha\n    Salva os dados em um array de strings\n    `\"]\n    end\n    C -- cria_jogadores --> D[\"`Cria os jogadores e seus pokemons,\n    inicializando os seus atributos(nome, hp, atk, def, tipo)\n    `\"]\n    D -- inicia_jogo --> E[Enquanto houverem sobreviventes]",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718474922375,
        "type": "auto",
        "id": "8b88494c-e495-47e2-b74f-d8748495aa4e",
        "name": "purring-russia"
    },
    {
        "state": {
            "code": "flowchart TD\n    A[Início] -- main --> B[/Recebe o nome do arquivo de entrada/]\n    B -- le_arquivo --> C[\"`Lê o arquivo linha a linha\n    Salva os dados em um array de strings\n    `\"]\n    C -- cria_jogadores --> D[\"`Cria os jogadores e seus pokemons,\n    inicializando os seus atributos(nome, hp, atk, def, tipo)\n    `\"]\n    D -- inicia_jogo --> E[Enquanto houverem sobreviventes]",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718474862960,
        "type": "auto",
        "id": "9e4c7d9b-4bd6-4362-a3ad-fd867713387b",
        "name": "obnoxious-car"
    },
    {
        "state": {
            "code": "flowchart TD\n    A[Início] -- main --> B[/Recebe o nome do arquivo de entrada/]\n    B -- le_arquivo --> C[\"`Lê o arquivo linha a linha\n    Salva os dados em um array de strings\n    `\"]\n    C -- cria_jogadores --> D[\"`Cria os jogadores e seus pokemons,\n    inicializando os seus atributos(nome, hp, atk, def, tipo)\n    `\"]\n    D -- inicia_jogo --> E",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "pan": {
                "x": 369.3538306451613,
                "y": 9.622119815668214
            },
            "zoom": 1.000000000920078,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718474802376,
        "type": "auto",
        "id": "032299c3-8f71-4cfb-845e-1b6f9d860658",
        "name": "plain-secretary"
    },
    {
        "state": {
            "code": "flowchart TD\n    A[Início] -- main --> B[/Recebe o nome do arquivo de entrada/]\n    B -- le_arquivo --> C[\"`Lê o arquivo linha a linha\n    Salva os dados em um array de strings\n    `\"]\n    C -- cria_jogadores --> D[\"`Cria os jogadores e seus pokemons,\n    inicializando os seus atributos(nome, hp, atk, def, tipo)\n    `\"]\n    D --> E",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718474742366,
        "type": "auto",
        "id": "1c5b0301-c325-42b4-9ed6-f17b497af415",
        "name": "bright-russia"
    },
    {
        "state": {
            "code": "flowchart TD\n    A[Início] --> B[/Recebe o nome do arquivo de entrada/]\n    B --> C[\"`Lê o arquivo linha a linha\n    Salva os dados em um array de strings\n    `\"]\n    C --> D[\"`Cria os jogadores e seus pokemons,\n    inicializando os seus atributos(hp, atk, def, tipo)\n    `\"]",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718474682365,
        "type": "auto",
        "id": "61c471eb-66ec-4d20-8a0f-de896390e97a",
        "name": "red-cat"
    },
    {
        "state": {
            "code": "flowchart TD\n    A[Início] --> B[/Recebe o nome do arquivo de entrada/]\n    B --> C[\"`Lê o arquivo linha a linha\n    Salva os dados em um array de strings\n    `\"]\n    C --> D[\"`Cria os jogadores:\n    \n    `\"]",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718474622364,
        "type": "auto",
        "id": "e848397a-9c5c-4bbb-bd68-43ed16a9a21c",
        "name": "deep-florist"
    },
    {
        "state": {
            "code": "flowchart TD\n    A[Início] --> B[/Recebe o nome do arquivo de entrada/]\n    B --> C[\"`- Lê o arquivo linha a linha\n    Salva os dados em um array de strings\n    `\"]\n    C --> D[\"`Cria os jogadores:\n    \n    `\"]",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718474562969,
        "type": "auto",
        "id": "ff953b83-3bb1-49d0-be47-b8b87cdb2c15",
        "name": "aloof-girl"
    },
    {
        "state": {
            "code": "flowchart TD\n    A[Início] --> B[/Recebe o nome do arquivo de entrada/]\n    B --> C[\"`Lê o arquivo\n    Salva os dados em um array de strings\n    `\"]\n    C --> D[Cria os joga]",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718474502380,
        "type": "auto",
        "id": "e464a354-244d-408d-a2d7-729294c832d3",
        "name": "rough-potato"
    },
    {
        "state": {
            "code": "flowchart TD\n    A[Início] --> B[/Recebe o nome do arquivo de entrada/]\n    B --> C[\"`Lê o arquivo e salva \n    `\"]",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718474442379,
        "type": "auto",
        "id": "dc6a431f-f744-4ffd-91ec-670fed29f5da",
        "name": "little-coat"
    },
    {
        "state": {
            "code": "flowchart TD\n    A[Início] --> B[/Recebe o nome do arquivo de entrada/]\n    B --> C[Lê]",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718474382372,
        "type": "auto",
        "id": "c5bc5f29-aae5-4250-a795-bdfdc02038f0",
        "name": "delightful-rose"
    },
    {
        "state": {
            "code": "flowchart TD\n    A[Início] --> B[/Nome do arquivo/]\n    B --> C",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718474322964,
        "type": "auto",
        "id": "89e67bd3-3764-4dd1-b2bc-1bc5c38657ba",
        "name": "proud-wolf"
    },
    {
        "state": {
            "code": "flowchart TD\n    A[Início] --> B[/Nome do arquivo/]\n    B --> C{Let me think}\n    C -->|One| D[Laptop]\n    C -->|Two| E[iPhone]\n    C -->|Three| F[fa:fa-car Car]",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "editorMode": "code",
            "panZoom": false
        },
        "time": 1718471502365,
        "type": "auto",
        "id": "8f9cf764-faf1-46b8-88cd-bd8fc6a10ade",
        "name": "young-afternoon"
    },
    {
        "state": {
            "code": "flowchart TD\n    A[Início] --> B(Go shopping)\n    B --> C{Let me think}\n    C -->|One| D[Laptop]\n    C -->|Two| E[iPhone]\n    C -->|Three| F[fa:fa-car Car]",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "editorMode": "code"
        },
        "time": 1718470782972,
        "type": "auto",
        "id": "5bd36d05-14cd-43c7-b212-02e53bd5bb09",
        "name": "squeaking-advertisement"
    },
    {
        "state": {
            "code": "flowchart TD\n    A[Main] ---> B(Go shopping)\n    B --> C{Let me think}\n    C -->|One| D[Laptop]\n    C -->|Two| E[iPhone]\n    C -->|Three| F[fa:fa-car Car]",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": false,
            "editorMode": "code"
        },
        "time": 1718470722376,
        "type": "auto",
        "id": "69374877-87ab-4450-b3c9-a88d6c6173db",
        "name": "abiding-advantage"
    },
    {
        "state": {
            "code": "flowchart TD\n    A[Christmas] -->|Get money| B(Go shopping)\n    B --> C{Let me think}\n    C -->|One| D[Laptop]\n    C -->|Two| E[iPhone]\n    C -->|Three| F[fa:fa-car Car]",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true,
            "editorMode": "code"
        },
        "time": 1718470602379,
        "type": "auto",
        "id": "7722c64f-8abe-4fda-8195-b951e7bc9544",
        "name": "fierce-caravan"
    },
    {
        "state": {
            "code": "flowchart TD\n    A[Christmas] -->|Get money| B(Go shopping)\n    B --> C{Let me think}\n    C -->|One| D[Laptop]\n    C -->|Two| E[iPhone]\n    C -->|Three| F[fa:fa-car Car]",
            "mermaid": "{\n  \"theme\": \"dark\"\n}",
            "autoSync": true,
            "rough": false,
            "updateDiagram": true
        },
        "time": 1718470542366,
        "type": "auto",
        "id": "aa7ea451-639d-49f1-b249-0e0f98b3488d",
        "name": "chubby-zebra"
    }
]